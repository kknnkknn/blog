<!doctype html><html lang=ja><head><title>AVL木の性質 · ___
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="nk"><meta name=description content="はじめに 見出しへのリンク 平衡二分探索木の実装と使い分けを整理したくなったので、簡潔にまとめる。
数あるバリエーションのうち、本記事では
AVL木（高さ差を±1で厳密に保つ・簡潔な実装） に絞って解説する。 赤黒木や Treap などの他の平衡二分探索木については後日記事を追加する予定。
参考文献は主に『アルゴリズムイントロダクション』（第3版和訳）と Sedgewick & Wayne『Algorithms, 4th Edition』を参照。誤りがあれば指摘求む。
基本概念 見出しへのリンク ノードの構造とバランス係数 見出しへのリンク 高さの上界と計算量 見出しへのリンク BST との違い・メリット 見出しへのリンク 回転パターンの図解 見出しへのリンク 次は回転について説明する。 平衡二分探索木では、木の順序(左ノード < 親ノード < 右ノード) を 壊さずに高さを整えるために回転という操作を行う。 AVL 木で実際に必要な回転は次の 4 パターン だけ。
LL（右回転） 見出しへのリンク 色付きのノードを右に回転する
4 の左の子を 2 の右の部分木(3)につけ直す 2 をルートにして、4 を 2 の右の子として接続する 4 -> 2 の順に高さ/バランス係数を再計算する RR（左回転） 見出しへのリンク LL(右回転)を逆にしただけ。 手順は
1 の右の子を 3 の左の部分木(2)につけ直す 3 をルートにして、1 を 3 の左の子として接続する 1 -> 3 の順に高さ/バランス係数を再計算する LR（左‑右回転） 見出しへのリンク 左のノードの右部分木が伸びているパターン。 １回右回転してLLのパターンにしてから左に回転してバランスを取る。 RL（右‑左回転） 見出しへのリンク 実装(C++) 見出しへのリンク ノードと木の定義 見出しへのリンク template <typename T> struct AVLNode { T data; AVLNode* left = nullptr; AVLNode* right = nullptr; int8_t balance = 0; // -1 <= balance <= 1 }; template <typename T> class AVLTree { public: void insert(const T& key); void erase(const T& key); bool search(const T& key) const; void clear(); private: AVLNode<T> *root = nullptr; int height(AVLNode<T>* n) const; void update(AVLNode<T>* n); AVLNode<T> *rotateLeft(AVLNode<T> *x); AVLNode<T> *rotateRight(AVLNode<T> *y); AVLNode<T> *rebalance(AVLNode<T> *n); AVLNode<T> *insertImpl(AVLNode<T> *n, const T& key); AVLNode<T> *eraseImpl(AVLNode<T> *n, const T& key); }; 挿入 見出しへのリンク template<typename T> void AVLTree<T>::insert(const T& key) { root = insertImpl(root, key); } template<typename T> AVLNode<T>* AVLTree<T>::insertImpl(AVLNode<T> *n, const T& key) { if (n == nullptr) { return new AVLNode<T>(key, nullptr, nullptr, 0); } if (n->data > key) { n->left = insertImpl(n->left, key); } else if (n->data < key) { n->right = insertImpl(n->right, key); } else { return n; } n->bal = height(n->left) - height(n->right); return rebalance(n); } 削除 見出しへのリンク 探索 見出しへのリンク テスト用 main と assert 見出しへのリンク ユースケースと実務採用例 見出しへのリンク SQLite インデックス 競技プログラミング用ライブラリ その他 DB エンジンとの比較 8."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="AVL木の性質"><meta name=twitter:description content="はじめに 見出しへのリンク 平衡二分探索木の実装と使い分けを整理したくなったので、簡潔にまとめる。
数あるバリエーションのうち、本記事では
AVL木（高さ差を±1で厳密に保つ・簡潔な実装） に絞って解説する。 赤黒木や Treap などの他の平衡二分探索木については後日記事を追加する予定。
参考文献は主に『アルゴリズムイントロダクション』（第3版和訳）と Sedgewick & Wayne『Algorithms, 4th Edition』を参照。誤りがあれば指摘求む。
基本概念 見出しへのリンク ノードの構造とバランス係数 見出しへのリンク 高さの上界と計算量 見出しへのリンク BST との違い・メリット 見出しへのリンク 回転パターンの図解 見出しへのリンク 次は回転について説明する。 平衡二分探索木では、木の順序(左ノード < 親ノード < 右ノード) を 壊さずに高さを整えるために回転という操作を行う。 AVL 木で実際に必要な回転は次の 4 パターン だけ。
LL（右回転） 見出しへのリンク 色付きのノードを右に回転する
4 の左の子を 2 の右の部分木(3)につけ直す 2 をルートにして、4 を 2 の右の子として接続する 4 -> 2 の順に高さ/バランス係数を再計算する RR（左回転） 見出しへのリンク LL(右回転)を逆にしただけ。 手順は
1 の右の子を 3 の左の部分木(2)につけ直す 3 をルートにして、1 を 3 の左の子として接続する 1 -> 3 の順に高さ/バランス係数を再計算する LR（左‑右回転） 見出しへのリンク 左のノードの右部分木が伸びているパターン。 １回右回転してLLのパターンにしてから左に回転してバランスを取る。 RL（右‑左回転） 見出しへのリンク 実装(C++) 見出しへのリンク ノードと木の定義 見出しへのリンク template <typename T> struct AVLNode { T data; AVLNode* left = nullptr; AVLNode* right = nullptr; int8_t balance = 0; // -1 <= balance <= 1 }; template <typename T> class AVLTree { public: void insert(const T& key); void erase(const T& key); bool search(const T& key) const; void clear(); private: AVLNode<T> *root = nullptr; int height(AVLNode<T>* n) const; void update(AVLNode<T>* n); AVLNode<T> *rotateLeft(AVLNode<T> *x); AVLNode<T> *rotateRight(AVLNode<T> *y); AVLNode<T> *rebalance(AVLNode<T> *n); AVLNode<T> *insertImpl(AVLNode<T> *n, const T& key); AVLNode<T> *eraseImpl(AVLNode<T> *n, const T& key); }; 挿入 見出しへのリンク template<typename T> void AVLTree<T>::insert(const T& key) { root = insertImpl(root, key); } template<typename T> AVLNode<T>* AVLTree<T>::insertImpl(AVLNode<T> *n, const T& key) { if (n == nullptr) { return new AVLNode<T>(key, nullptr, nullptr, 0); } if (n->data > key) { n->left = insertImpl(n->left, key); } else if (n->data < key) { n->right = insertImpl(n->right, key); } else { return n; } n->bal = height(n->left) - height(n->right); return rebalance(n); } 削除 見出しへのリンク 探索 見出しへのリンク テスト用 main と assert 見出しへのリンク ユースケースと実務採用例 見出しへのリンク SQLite インデックス 競技プログラミング用ライブラリ その他 DB エンジンとの比較 8."><meta property="og:url" content="https://kknnkknn.github.io/blog/article/avl-balance-tree/"><meta property="og:site_name" content="___"><meta property="og:title" content="AVL木の性質"><meta property="og:description" content="はじめに 見出しへのリンク 平衡二分探索木の実装と使い分けを整理したくなったので、簡潔にまとめる。
数あるバリエーションのうち、本記事では
AVL木（高さ差を±1で厳密に保つ・簡潔な実装） に絞って解説する。 赤黒木や Treap などの他の平衡二分探索木については後日記事を追加する予定。
参考文献は主に『アルゴリズムイントロダクション』（第3版和訳）と Sedgewick & Wayne『Algorithms, 4th Edition』を参照。誤りがあれば指摘求む。
基本概念 見出しへのリンク ノードの構造とバランス係数 見出しへのリンク 高さの上界と計算量 見出しへのリンク BST との違い・メリット 見出しへのリンク 回転パターンの図解 見出しへのリンク 次は回転について説明する。 平衡二分探索木では、木の順序(左ノード < 親ノード < 右ノード) を 壊さずに高さを整えるために回転という操作を行う。 AVL 木で実際に必要な回転は次の 4 パターン だけ。
LL（右回転） 見出しへのリンク 色付きのノードを右に回転する
4 の左の子を 2 の右の部分木(3)につけ直す 2 をルートにして、4 を 2 の右の子として接続する 4 -> 2 の順に高さ/バランス係数を再計算する RR（左回転） 見出しへのリンク LL(右回転)を逆にしただけ。 手順は
1 の右の子を 3 の左の部分木(2)につけ直す 3 をルートにして、1 を 3 の左の子として接続する 1 -> 3 の順に高さ/バランス係数を再計算する LR（左‑右回転） 見出しへのリンク 左のノードの右部分木が伸びているパターン。 １回右回転してLLのパターンにしてから左に回転してバランスを取る。 RL（右‑左回転） 見出しへのリンク 実装(C++) 見出しへのリンク ノードと木の定義 見出しへのリンク template <typename T> struct AVLNode { T data; AVLNode* left = nullptr; AVLNode* right = nullptr; int8_t balance = 0; // -1 <= balance <= 1 }; template <typename T> class AVLTree { public: void insert(const T& key); void erase(const T& key); bool search(const T& key) const; void clear(); private: AVLNode<T> *root = nullptr; int height(AVLNode<T>* n) const; void update(AVLNode<T>* n); AVLNode<T> *rotateLeft(AVLNode<T> *x); AVLNode<T> *rotateRight(AVLNode<T> *y); AVLNode<T> *rebalance(AVLNode<T> *n); AVLNode<T> *insertImpl(AVLNode<T> *n, const T& key); AVLNode<T> *eraseImpl(AVLNode<T> *n, const T& key); }; 挿入 見出しへのリンク template<typename T> void AVLTree<T>::insert(const T& key) { root = insertImpl(root, key); } template<typename T> AVLNode<T>* AVLTree<T>::insertImpl(AVLNode<T> *n, const T& key) { if (n == nullptr) { return new AVLNode<T>(key, nullptr, nullptr, 0); } if (n->data > key) { n->left = insertImpl(n->left, key); } else if (n->data < key) { n->right = insertImpl(n->right, key); } else { return n; } n->bal = height(n->left) - height(n->right); return rebalance(n); } 削除 見出しへのリンク 探索 見出しへのリンク テスト用 main と assert 見出しへのリンク ユースケースと実務採用例 見出しへのリンク SQLite インデックス 競技プログラミング用ライブラリ その他 DB エンジンとの比較 8."><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="article"><meta property="article:published_time" content="2025-04-20T23:01:52+09:00"><meta property="article:modified_time" content="2025-04-20T23:01:52+09:00"><link rel=canonical href=https://kknnkknn.github.io/blog/article/avl-balance-tree/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/blog/css/coder.min.38c4552ac40f9ae3408bad40358f654ebd8804412fe74ed56f2d6c8a7af82dd3.css integrity="sha256-OMRVKsQPmuNAi61ANY9lTr2IBEEv507Vby1sinr4LdM=" crossorigin=anonymous media=screen><link rel=stylesheet href=/blog/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/blog/css/custom.css media=screen><link rel=icon type=image/svg+xml href=/images/icon.svg sizes=any><link rel=icon type=image/png href=/images/favicon.ico sizes=32x32><link rel=icon type=image/png href=/images/favicon.ico sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://kknnkknn.github.io/blog/>___
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/blog/article/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/blog/about/>About</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://kknnkknn.github.io/blog/article/avl-balance-tree/>AVL木の性質</a></h1></header><h2 id=はじめに>はじめに
<a class=heading-link href=#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><p>平衡二分探索木の実装と使い分けを整理したくなったので、簡潔にまとめる。<br>数あるバリエーションのうち、本記事では</p><ul><li><strong>AVL木</strong>（高さ差を±1で厳密に保つ・簡潔な実装）</li></ul><p>に絞って解説する。
赤黒木や Treap などの他の平衡二分探索木については後日記事を追加する予定。</p><p>参考文献は主に『アルゴリズムイントロダクション』（第3版和訳）と
Sedgewick & Wayne『Algorithms, 4th Edition』を参照。誤りがあれば指摘求む。</p><h2 id=基本概念>基本概念
<a class=heading-link href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><h3 id=ノードの構造とバランス係数>ノードの構造とバランス係数
<a class=heading-link href=#%e3%83%8e%e3%83%bc%e3%83%89%e3%81%ae%e6%a7%8b%e9%80%a0%e3%81%a8%e3%83%90%e3%83%a9%e3%83%b3%e3%82%b9%e4%bf%82%e6%95%b0><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h3 id=高さの上界と計算量>高さの上界と計算量
<a class=heading-link href=#%e9%ab%98%e3%81%95%e3%81%ae%e4%b8%8a%e7%95%8c%e3%81%a8%e8%a8%88%e7%ae%97%e9%87%8f><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h3 id=bst-との違いメリット>BST との違い・メリット
<a class=heading-link href=#bst-%e3%81%a8%e3%81%ae%e9%81%95%e3%81%84%e3%83%a1%e3%83%aa%e3%83%83%e3%83%88><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h2 id=回転パターンの図解>回転パターンの図解
<a class=heading-link href=#%e5%9b%9e%e8%bb%a2%e3%83%91%e3%82%bf%e3%83%bc%e3%83%b3%e3%81%ae%e5%9b%b3%e8%a7%a3><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><p>次は回転について説明する。
平衡二分探索木では、木の順序(左ノード &lt; 親ノード &lt; 右ノード) を
壊さずに高さを整えるために<strong>回転</strong>という操作を行う。
AVL 木で実際に必要な回転は次の <strong>4 パターン</strong> だけ。</p><h3 id=ll右回転>LL（右回転）
<a class=heading-link href=#ll%e5%8f%b3%e5%9b%9e%e8%bb%a2><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><p><img src=/blog/images/LL.png alt=LL.png></p><p>色付きのノードを右に回転する</p><ol><li>4 の左の子を 2 の右の部分木(3)につけ直す</li><li>2 をルートにして、4 を 2 の右の子として接続する</li><li>4 -> 2 の順に高さ/バランス係数を再計算する</li></ol><h3 id=rr左回転>RR（左回転）
<a class=heading-link href=#rr%e5%b7%a6%e5%9b%9e%e8%bb%a2><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><p>LL(右回転)を逆にしただけ。
<img src=/blog/images/RR.png alt=RR.png>
手順は</p><ol><li>1 の右の子を 3 の左の部分木(2)につけ直す</li><li>3 をルートにして、1 を 3 の左の子として接続する</li><li>1 -> 3 の順に高さ/バランス係数を再計算する</li></ol><h3 id=lr左右回転>LR（左‑右回転）
<a class=heading-link href=#lr%e5%b7%a6%e5%8f%b3%e5%9b%9e%e8%bb%a2><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><p>左のノードの右部分木が伸びているパターン。
１回右回転してLLのパターンにしてから左に回転してバランスを取る。
<img src=/blog/images/LR.png alt=LR.png></p><h3 id=rl右左回転>RL（右‑左回転）
<a class=heading-link href=#rl%e5%8f%b3%e5%b7%a6%e5%9b%9e%e8%bb%a2><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h2 id=実装c>実装(C++)
<a class=heading-link href=#%e5%ae%9f%e8%a3%85c><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><h3 id=ノードと木の定義>ノードと木の定義
<a class=heading-link href=#%e3%83%8e%e3%83%bc%e3%83%89%e3%81%a8%e6%9c%a8%e3%81%ae%e5%ae%9a%e7%be%a9><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span> <span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> <span style=color:#f0883e;font-weight:700>AVLNode</span> {
</span></span><span style=display:flex><span>    T data;
</span></span><span style=display:flex><span>    AVLNode<span style=color:#ff7b72;font-weight:700>*</span> left  <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>nullptr</span>;
</span></span><span style=display:flex><span>    AVLNode<span style=color:#ff7b72;font-weight:700>*</span> right <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int8_t</span> balance <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>0</span>;   <span style=color:#8b949e;font-style:italic>// -1 &lt;= balance &lt;= 1
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>template</span> <span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>AVLTree</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span><span style=color:#ff7b72;font-weight:700>:</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span> insert(<span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key);
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>erase</span>(<span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key);
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>bool</span> <span style=color:#d2a8ff;font-weight:700>search</span>(<span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key) <span style=color:#ff7b72>const</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>clear</span>();
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span><span style=color:#ff7b72;font-weight:700>:</span>
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>root <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>nullptr</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>height</span>(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;*</span> n) <span style=color:#ff7b72>const</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>update</span>(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;*</span> n);
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>rotateLeft(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>x);
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>rotateRight(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>y);
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>rebalance(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>n);
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>insertImpl(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>n, <span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key);
</span></span><span style=display:flex><span>        AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>eraseImpl(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>n, <span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=挿入>挿入
<a class=heading-link href=#%e6%8c%bf%e5%85%a5><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ff7b72>template</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span> 
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>void</span> AVLTree<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;::</span>insert(<span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key) {
</span></span><span style=display:flex><span>  root <span style=color:#ff7b72;font-weight:700>=</span> insertImpl(root, key);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>template</span><span style=color:#ff7b72;font-weight:700>&lt;</span><span style=color:#ff7b72>typename</span> T<span style=color:#ff7b72;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>  AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;*</span> AVLTree<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;::</span>insertImpl(AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>*</span>n, <span style=color:#ff7b72>const</span> T<span style=color:#ff7b72;font-weight:700>&amp;</span> key) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>if</span> (n <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#ff7b72>nullptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> <span style=color:#ff7b72>new</span> AVLNode<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span>(key, <span style=color:#ff7b72>nullptr</span>, <span style=color:#ff7b72>nullptr</span>, <span style=color:#a5d6ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>if</span> (n<span style=color:#ff7b72;font-weight:700>-&gt;</span>data <span style=color:#ff7b72;font-weight:700>&gt;</span> key) {
</span></span><span style=display:flex><span>    n<span style=color:#ff7b72;font-weight:700>-&gt;</span>left <span style=color:#ff7b72;font-weight:700>=</span> insertImpl(n<span style=color:#ff7b72;font-weight:700>-&gt;</span>left, key);
</span></span><span style=display:flex><span>  } <span style=color:#ff7b72>else</span> <span style=color:#d2a8ff;font-weight:700>if</span> (n<span style=color:#ff7b72;font-weight:700>-&gt;</span>data <span style=color:#ff7b72;font-weight:700>&lt;</span> key) {
</span></span><span style=display:flex><span>    n<span style=color:#ff7b72;font-weight:700>-&gt;</span>right <span style=color:#ff7b72;font-weight:700>=</span> insertImpl(n<span style=color:#ff7b72;font-weight:700>-&gt;</span>right, key);
</span></span><span style=display:flex><span>  } <span style=color:#ff7b72>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> n;
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>  n<span style=color:#ff7b72;font-weight:700>-&gt;</span>bal <span style=color:#ff7b72;font-weight:700>=</span> height(n<span style=color:#ff7b72;font-weight:700>-&gt;</span>left) <span style=color:#ff7b72;font-weight:700>-</span> height(n<span style=color:#ff7b72;font-weight:700>-&gt;</span>right);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>return</span> <span style=color:#d2a8ff;font-weight:700>rebalance</span>(n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=削除>削除
<a class=heading-link href=#%e5%89%8a%e9%99%a4><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h3 id=探索>探索
<a class=heading-link href=#%e6%8e%a2%e7%b4%a2><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h3 id=テスト用-main-と-assert>テスト用 main と assert
<a class=heading-link href=#%e3%83%86%e3%82%b9%e3%83%88%e7%94%a8-main-%e3%81%a8-assert><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h3><h2 id=ユースケースと実務採用例>ユースケースと実務採用例
<a class=heading-link href=#%e3%83%a6%e3%83%bc%e3%82%b9%e3%82%b1%e3%83%bc%e3%82%b9%e3%81%a8%e5%ae%9f%e5%8b%99%e6%8e%a1%e7%94%a8%e4%be%8b><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><ul><li>SQLite インデックス</li><li>競技プログラミング用ライブラリ</li><li>その他 DB エンジンとの比較</li></ul><h2 id=8-参考文献リンク集>8. 参考文献・リンク集
<a class=heading-link href=#8-%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae%e3%83%aa%e3%83%b3%e3%82%af%e9%9b%86><i class="fa-solid fa-link" aria-hidden=true title=見出しへのリンク></i>
<span class=sr-only>見出しへのリンク</span></a></h2><ul><li>『アルゴリズムイントロダクション』3 版</li><li>Sedgewick & Wayne “Algorithms, 4th Ed.”</li><li>GNU libavl 2.0 ドキュメント</li></ul></article></section></div><footer class=footer><section class=container>©
2025
nk</section></footer></main><script src=/blog/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EM72XSTWPY"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EM72XSTWPY")}</script></body></html>